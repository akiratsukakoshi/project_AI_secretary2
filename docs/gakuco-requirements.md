# GAKU-CO (ガクコ) AI秘書 - プロジェクト要件定義書

## 1. プロジェクト概要

### 1.1 背景
- 情報が様々なアプリケーションに分散していて呼び出しに手間がかかる
- ルーチン作業が創造的な仕事の時間を圧迫している
- スケジュール管理やタスク管理に課題がある
- チームメンバーのITリテラシーに差がある

### 1.2 プロジェクトゴール
チームをサポートするAI秘書「gaku-co（ガクコ）」を立ち上げ、チームメンバーが本来の創造的な仕事に集中できる環境を構築する。

### 1.3 実現する主な機能
- Discordをインターフェースとした自然言語コミュニケーション
- 生成AIをコアとした知的対話システム
- モジュール化されたワークフローによる業務サポート
  - スケジュール管理、タスク管理、伝票処理、検索など
  - STORES予約管理ツールとのAPI連携
- RAG（検索拡張生成）を活用した知識データベース
  - イベント情報、顧客情報の検索
  - サービス概要やFAQの参照
  - 会議履歴の確認

### 1.4 技術環境
- VPSサーバー上で常時稼働
- 仮想6コア、8GBメモリ、NVMe400GB
- 月間API利用コスト目標：20ドル以下

## 2. システムアーキテクチャ設計

### 2.1 全体構成
- Discord Bot：ユーザーインターフェース
- RAGシステム：知識ベース検索
- ワークフローエンジン：業務プロセス自動化
- メモリシステム：会話コンテキスト管理
- LLM (大規模言語モデル)：自然言語処理エンジン

### 2.2 主要コンポーネント間の連携
```
ユーザー (Discord) → Discord Bot → MCPワークフロー → 応答 → ユーザー (Discord)
```

詳細プロセスフロー:
1. ユーザー入力 (Discord)
2. Discord Bot が入力を受信
3. インメモリキャッシュで会話履歴を更新
4. Supabase MCP ワークフローを起動
5. 入力分析と意図理解
6. アクション判断（通常会話/RAG検索/ワークフロー実行）
7. 必要に応じてRAG検索やワークフロー実行
8. 適切なプロンプト構築
9. LLMに最終プロンプトを送信
10. 応答生成
11. フォーマット調整
12. Discord Botを通じて応答を送信
13. 会話履歴の永続化

## 3. RAGシステム設計

### 3.1 RAGアーキテクチャ
- **チャンキング戦略**:
  - FAQや会議録: 意味のある単位（質問-回答ペア、議題単位）でチャンキング
  - イベント情報: 1イベント1チャンク
  - 顧客情報: 1顧客1チャンク + メタデータ（アレルギー情報などをメタデータとして保存）

- **リトリーバル方式**:
  - ハイブリッドリトリーバル: ベクトル検索 + キーワード検索
  - 日付検索などの構造化データはメタデータとして扱い、フィルターとして活用

- **再ランキング**:
  - 最初は単純なベクトル検索のみでスタート
  - 精度に問題が出てきたら、LLM基づく再ランキングを導入

### 3.2 データソース
1. gaku-co自身の基本情報
   - 役割や性格など基本的なプロンプト

2. 業務情報
   - サービス情報（Webサイトから取得）
   - FAQ
   - イベント情報（STORES予約API）
   - 顧客情報（STORES予約API）
   - スタッフ情報（スプレッドシート）
   - 会議録（テキストまたはGoogle Docs）

### 3.3 データ形式と更新頻度
- 顧客情報: CSV形式、毎日更新
- 会議メモ: テキストまたはGoogle Docs、週1-2回更新
- イベント情報: CSV形式、月1-2回更新
- その他情報: ほぼ変更なし

### 3.4 技術スタック
- 埋め込みモデル: OpenAI text-embedding-3-small
- ベクトルデータベース: Supabase pgvector
- データ処理: 必要に応じてSupabase MCP

## 4. メモリ管理設計

### 4.1 実装方法
- インメモリキャッシュ + DB永続化
- アクティブな会話はNodeJSのインメモリ構造（MapまたはRedis）で管理
- 定期的または会話の区切りで、Supabaseに永続化
- サーバーダウン時の直近会話の損失は許容

### 4.2 会話コンテキスト管理
- Discord ユーザーID + チャンネルIDで一意の会話を識別
- ユーザーごとにパーソナライズされた会話コンテキストを維持

### 4.3 メモリの構造化
- スライディングウィンドウ + サマリー方式を採用
- 最新N件（例：10〜20件）のメッセージは完全な形で保持
- 古いメッセージはLLMでサマリー化して「過去の会話の要約」として保持

## 5. ワークフロー連携設計

### 5.1 実装アプローチ
- ハイブリッドアプローチ
  - 基本は自然なインテント認識で自動実行
  - 複雑/重要なワークフローには明示的なトリガーワードも残す
  - 例：「予定を確認して」（自動認識）vs「ガクコお願い、新規予約登録」（明示的）

### 5.2 段階的実装
- 初期段階：よく使うワークフローを自動インテント認識に移行
- 中間段階：ユーザーフィードバックを取り入れながら調整
- 最終段階：ほとんどのワークフローを自然な対話で起動可能に

### 5.3 フォールバックメカニズム
- 自動認識が不確かな場合、「〜というタスクを実行しますか？」と確認
- ユーザーが望む結果でない場合に「ガクコお願い」でオーバーライド可能に

## 6. STORES予約APIとのデータ連携

### 6.1 データ取得とインデックス更新フロー
```
定期実行スクリプト → STORES API呼び出し → データ変換処理 → Supabaseインデックス更新
```

### 6.2 実装アプローチ
- 別システムとしてn8nまたはシンプルなスケジュールされたスクリプトで実装
- 前回取得時からの差分のみを処理する仕組みを導入し、効率化
- API利用回数を適切に制御（一定期間内の過剰リクエストを避ける）

### 6.3 メタデータ活用
- 日付、アレルギー情報などの構造化データをメタデータとしてインデックス
- RAG検索時にこれらをフィルターとして活用

### 6.4 データマッピング
- イベントデータ: 1イベント1チャンクでインデックス
- 顧客データ: 1顧客1チャンクでインデックス、アレルギー情報などを明示的にメタデータ化

## 7. アクセス制御と権限管理

### 7.1 アクセス制御システム
- Discordサーバー（ギルド）IDとチャンネルIDに基づく権限システム
- 複数の権限レベル設定
- Supabaseに権限マッピングテーブルを作成

### 7.2 実装詳細
- 権限テーブルで各サーバー/チャンネルの利用可能機能を管理
- コアメンバーのサーバーでのみ機密情報アクセスを許可

### 7.3 権限チェックフロー
- メッセージ受信時にIDを抽出し権限を確認
- 許可されていない機能へのアクセス試行時は適切なエラーメッセージを表示

## 8. プロンプトエンジニアリング

### 8.1 階層型プロンプト構造
- **コアプロンプト**: gaku-co（ガクコ）の基本的な振る舞い、性格、役割を定義
- **コンテキストプロンプト**: 現在の会話履歴、ユーザーの過去の質問など
- **RAGプロンプト**: 検索結果から取得した関連情報
- **ワークフロープロンプト**: 必要なワークフローに関する指示やツール呼び出し方法

### 8.2 プロンプトテンプレート
- **RAG統合用テンプレート**:
  ```
  以下は[ユーザー名]さんからの質問と、関連する情報です。

  質問：[ユーザーの質問]

  関連情報：
  [RAGシステムから取得した情報]
  ソース：[情報ソース]

  上記の関連情報を参考にして、質問に答えてください。
  情報が不十分な場合は、その旨を伝え、どのような情報が必要かを示してください。
  情報の出典も含めて回答してください。
  ```

- **ワークフロー連携用テンプレート**:
  ```
  以下はユーザーの要求に基づいて実行すべきワークフローです。

  ユーザーの要求：[ユーザーの入力]
  実行するワークフロー：[ワークフロー名]
  ワークフローの説明：[ワークフローの概要]
  必要なパラメータ：[必要なパラメータリスト]

  このワークフローを実行するためには上記のパラメータが必要です。
  足りないパラメータがあれば質問してください。
  全てのパラメータが揃ったら、ワークフローを実行し、結果を報告してください。
  ```

- **メタデータフィルタリング用プロンプト**:
  ```
  検索クエリ：[ユーザーの質問からの検索クエリ]
  日付フィルター：[抽出された日付]
  顧客フィルター：[抽出された顧客名]
  イベントフィルター：[抽出されたイベント名]
  
  上記の条件に合致する情報を検索してください。
  ```

### 8.3 MCPとの連携
- Supabase MCPでワークフローをオーケストレーション
- テンプレートはSupabaseのテーブルに保存
- 動的なプロンプト構築による柔軟な対応

## 9. システム統合と拡張性

### 9.1 モジュラー設計（最重要）
- 各機能を独立したマイクロサービス的コンポーネントとして実装
- Discord Bot、RAGシステム、ワークフローエンジンを疎結合化
- 標準化されたAPIとインターフェースで連携
- 将来的に他のインターフェース（LINE、Facebook Messenger、音声認識など）への拡張を容易にする

### 9.2 新機能の追加容易性（重要）
- プラグイン方式でのワークフロー追加メカニズム実装
- 設定ファイルやデータベースでの外部設定化
- 新ワークフロー追加時に既存システムの修正が不要な設計
- 社内ニーズに応じた迅速な機能拡張を可能に

### 9.3 拡張ポイントの明確化（重要）
- ワークフロー追加のための明確な手順と標準テンプレート作成
- 新データソース接続のためのインターフェース標準化
- 社内開発者がシステムを理解し拡張できるドキュメント整備

## 10. 実装計画と優先順位

### 10.1 フェーズ1: コア機能の実装
- Discord Botの基本機能
- メモリ管理システム
- 基本的なRAGシステム（シンプルなベクトル検索のみ）
- 最も重要なワークフロー1〜2個の実装

### 10.2 フェーズ2: 拡張と安定化
- RAGシステムの改善（メタデータフィルター追加）
- 追加ワークフローの段階的実装
- ユーザーフィードバック機能の追加
- エラーハンドリングの強化

### 10.3 フェーズ3: 高度な機能追加
- より複雑なワークフローの実装
- STORES予約APIとの連携強化
- より高度なDiscord UI（ボタン、メニューなど）の活用
- 権限システムの完全実装

### 10.4 フェーズ4: 最適化と拡張
- パフォーマンス最適化
- RAG精度のさらなる向上
- 追加インターフェース検討（LINE、音声など）
- ドキュメント整備と保守性向上

## 11. テスト戦略

### 11.1 小規模スタートと実地チューニング
- まず最小限の機能セットで稼働させる
- 実際の使用フィードバックを元に調整
- 運用しながらRAGの精度や応答性を改善

### 11.2 コア機能の最小実装（MVP）
- 基本的なDiscordボット機能
- シンプルなRAGシステムの構築と接続
- 基本的な1〜2個のワークフロー実装

### 11.3 早期のVPS移植と常時稼働化
- 開発環境から本番環境への迅速な移行
- 安定した常時稼働体制の確立
- 基本的なモニタリングの設定

### 11.4 イテレーティブなテスト・改善サイクル
- リアルユーザーフィードバックの収集機能実装
- 週次/月次のRAG精度評価と改善
- ワークフロー追加と既存ワークフロー改善の並行実施

## 12. 技術スタック

### 12.1 フロントエンド
- Discord Bot (discord.js)

### 12.2 バックエンド
- Node.js
- TypeScript
- Supabase (PostgreSQL, pgvector)
- Supabase MCP (ワークフローエンジン)

### 12.3 AI・ML
- OpenAI/Claude API (LLM)
- OpenAI Embeddings (text-embedding-3-small)

### 12.4 外部連携
- STORES予約 API
- Google Drive API (必要に応じて)

### 12.5 インフラ
- VPSサーバー
- Redis (オプション、インメモリキャッシュ用)

## 13. 今後の検討事項

### 13.1 将来拡張の可能性
- LINE、Facebook Messengerなど他のメッセージングプラットフォームへの対応
- 音声インターフェースの追加
- モバイルアプリとの連携

### 13.2 セキュリティ考慮事項
- 顧客情報の適切な暗号化と取り扱い（後期フェーズで実装）
- 認証と権限管理の強化
- プライバシーポリシーの策定

## 14. まとめ

このプロジェクトでは、チームの効率向上と創造的業務への集中を目的としたAI秘書「gaku-co（ガクコ）」を構築します。Discord上でのナチュラルなインターフェースを通じて、情報検索、タスク管理、スケジュール管理などの機能を提供します。

モジュラー設計と段階的実装により、最小限の機能から始めて実際の使用を通じて継続的に改善していくアプローチを採用します。特に拡張性を重視し、将来的な機能追加や他プラットフォームへの対応が容易になるよう設計します。
